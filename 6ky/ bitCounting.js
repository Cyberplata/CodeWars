// Напишите функцию, которая принимает целое число в качестве входных данных и возвращает количество битов,
// которые равны единице в двоичном представлении этого числа.
// Вы можете гарантировать, что входные данные неотрицательны.
//
// Пример : Двоичное представление 1234 равно 10011010010, поэтому в этом случае функция должна вернуть 5

var countBits = function(n) {
    let count = 0;
    while (n > 0) {
        if (n % 2 === 1) count++;
        n = Math.floor(n / 2);
        console.log(n)
    }
    return count;
};

const res1 = countBits(1234) // 5
const res2 = countBits(4) // 1
const res3 = countBits(7) // 3
const res4 = countBits(9) // 2
const res5 = countBits(10) // 2

console.log(res1)
// console.log(res2)
// console.log(res3)
// console.log(res4)
// console.log(res5)

//var2
countBits = n => n.toString(2).split('0').join('').length;

//Что здесь происходит:
// 👉 n.toString(2)
// Преобразует число n в строку, представляющую его в двоичной системе счисления.
// 📌 Например:
// 1234.toString(2) → "10011010010"
//
// 👉 .split('0')
// Разбивает эту строку по символу '0', создавая массив из подстрок между нулями.
// 📌 Например:
// "10011010010".split('0') →
// ["1", "", "1", "1", "", "1", "", "", "1", "", ""]
//
// 👉 .join('')
// Склеивает все элементы массива обратно в одну строку, без символов '0', потому что мы разрезали по нулям.
// 📌 Например:
// ["1", "", "1", "1", "", "1", "", "", "1", "", ""].join('') → "11111"
//
// 👉 .length
// Возвращает длину получившейся строки.
// 📌 В примере:
// "11111".length → 5